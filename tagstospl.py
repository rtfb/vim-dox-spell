#!/usr/bin/env python

# This software is in public domain. It is intended to be customized by
# its nature. This program is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
# Please report bugs in VimDoxSpell to Vytautas.Shaltenis@gmail.com.
#
# VimDoxSpell's home page is at
# <http://rtfb.lt/projects/vim-dox-spell/>.
#
# MAINTAINER: Vytautas Saltenis <Vytautas.Shaltenis@gmail.com>
#
# Copyright (C) 2008, Vytautas Saltenis

import os
import sys
import getopt
import xml.dom.minidom


def getWordListFromTags (tagsFile):
    """Parses tags file, taking all the identifiers and stashing them
    into a list.
    """

    tags = open (tagsFile).readlines ()
    tags = filter (lambda l: not l.startswith ('!'), tags)
    words = map(lambda t: t.split ('\t')[0], tags)
    return words

def writeWordList (list, file):
    """Writes a given list of words to a given file. One word per line.
    """

    f = open (file, 'w')
    map(lambda w: f.write(w + '\n'), list)

def getText (nodelist):
    """Retrieves a text between XML tags.
    """

    rc = ''

    for node in nodelist:
        if node.nodeType == node.TEXT_NODE:
            rc = rc + node.data

    return rc

def parseDoxygenIndex (file):
    """Parses the index file generated by doxygen. The information that
    is of interest there, are the names of the function groups, so that
    they can also be added to the dictionary of known words. Returned
    in a list.
    """

    contents = open (file).read ()
    dom = xml.dom.minidom.parseString (contents)
    compounds = dom.getElementsByTagName ('compound')
    groupNames = []

    for c in compounds:
        if c.attributes['kind'].nodeValue == 'group':
            group = getText (c.getElementsByTagName ('name')[0].childNodes)
            groupNames.append (group)

    return groupNames

def writeEmptySplFile (homeDir):
    """This one is tricky, if you don't know how Vim deals with its
    spelling dictionaries. For a proper explanation, refer to Vim
    documentation, and here it is sufficient to say, that I need a
    file 'fromtags.utf-8.spl', that is an empty dictionary. Vim will
    then not complain about being unable to find a dictionary. And all
    the real dictionary will be handled through another file,
    'fromtags.utf-8.add.spl', which is generated by this program.
    """

    emptySplFile = 'VIMspell2\xff' + '\x00' * 13
    emptySplFilePath = homeDir + '/.vim/spell/' + myMetaSpellFile + '.utf-8.spl'
    open (emptySplFilePath, 'wb').write (emptySplFile)

def readThings (homeDir):
    """Reads tags and XML files to gather all the information needed
    to put into our dictionary of identifiers.
    """

    words = []

    if myTagsFile:
        words.extend(getWordListFromTags(myTagsFile))
        print 'tags read.'

    if myIndexXml:
        words.extend(parseDoxygenIndex(myIndexXml))
        print 'doxygen index read.'

    if len(words) == 0:
        print 'Warning: there is no words to be added to dictionary...'
        print 'Check if -t or -i options are specified.'

    return words

def writeThings (homeDir, things):
    """Writes the plain text list of identifiers and then calls Vim
    to generate an actual dictionary for its use.
    """

    dictFile = homeDir + '/.vim/spell/' + myMetaSpellFile + '.utf-8.add'
    writeWordList (things, dictFile)
    print 'word list written.'

    writeEmptySplFile (homeDir)

    # The following command line calls Vim to generate the binary
    # dictionary file it will actually be using, not the plain text
    # one we've just written with writeWordList.
    cmd = 'vim --cmd ":set encoding=utf-8" --cmd ":mkspell! %s" --cmd ":q"'
    os.system (cmd % (dictFile))
    print 'spl generated.'


def clearSpellFiles(homeDir):
    flist = [
        homeDir + '/.vim/spell/' + myMetaSpellFile + '.utf-8.spl',
        homeDir + '/.vim/spell/' + myMetaSpellFile + '.utf-8.add',
        homeDir + '/.vim/spell/' + myMetaSpellFile + '.utf-8.add.spl',
    ]

    # TODO: maybe we need to check if '.utf-8.spl' is empty spell file...
    # to prevent removing real spell files.

    for file in flist:
        if os.path.exists(file):
            print " ...removing: %s" % (file)
            os.remove(file)


def usage():
    """Prints usage information.
    """

    print """Usage: %(prog)s [-t <file>] [-i <file>] <metaspell>
       %(prog)s --clear <metaspell>

    -t <file>   tags file generated by Exuberant Ctags
    -i <file>   index xml file generated by Doxygen
    --clear     clear all generated spell files from your vim configuration
                directory
    -h, --help  this help

    <metaspell> name of vim spell file, that will be stored in your home
                directory:
                    ~/.vim/spell/<metaspell>.utf-8.spl
                    ~/.vim/spell/<metaspell>.utf-8.add
    """ % {'prog': sys.argv[0]}


def checkMetaSpellFileArg(args):
    global myMetaSpellFile

    if len(args) != 1:
        print "Metaspell file not specified. Nothing to do."
        print
        usage()
        sys.exit(2)
    else:
        myMetaSpellFile = args[0]


def main ():
    global myTagsFile, myIndexXml

    homeDir = os.environ['HOME']

    try:
        opts, args = getopt.getopt(sys.argv[1:], 't::i::h', ['help', 'clear'])
    except getopt.GetoptError, err:
        print str(err)
        print
        usage()
        sys.exit(2)

    myTagsFile = None
    myIndexXml = None

    for o, a in opts:
        if o == '-t':
            myTagsFile = a
        elif o == '-i':
            myIndexXml = a
        elif o == '--clear':
            checkMetaSpellFileArg(args)
            clearSpellFiles(homeDir)
            sys.exit()
        elif o in ('-h', '--help'):
            usage()
            sys.exit()
        else:
            assert False, "unhandled option"

    checkMetaSpellFileArg(args)

    things = readThings (homeDir)
    writeThings (homeDir, things)
    print 'Done.'

if __name__ == '__main__':
    main ()

