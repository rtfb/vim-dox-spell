#!/usr/bin/env python

# This software is in public domain. It is intended to be customized by
# its nature. This program is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
# Please report bugs in VimDoxSpell to Vytautas.Shaltenis@gmail.com.
#
# VimDoxSpell's home page is at
# <http://rtfb.lt/projects/vim-dox-spell/>.
#
# MAINTAINER: Vytautas Saltenis <Vytautas.Shaltenis@gmail.com>
#
# Copyright (C) 2008, Vytautas Saltenis

import os
import sys
import getopt
import xml.dom.minidom


def get_word_list_from_tags(tags_file):
    """Parses tags file, taking all the identifiers and stashing them
    into a list.
    """

    tags = open(tags_file).readlines()
    tags = filter(lambda l: not l.startswith('!'), tags)
    words = map(lambda t: t.split('\t')[0], tags)
    return words


def write_word_list(list, file):
    """Writes a given list of words to a given file. One word per line.
    """

    f = open(file, 'w')
    map(lambda w: f.write(w + '\n'), list)


def get_text(nodelist):
    """Retrieves a text between XML tags.
    """

    rc = ''

    for node in nodelist:
        if node.nodeType == node.TEXT_NODE:
            rc = rc + node.data

    return rc


def parse_doxygen_index(file):
    """Parses the index file generated by doxygen. The information that
    is of interest there, are the names of the function groups, so that
    they can also be added to the dictionary of known words. Returned
    in a list.
    """

    contents = open(file).read()
    dom = xml.dom.minidom.parseString(contents)
    compounds = dom.getElementsByTagName('compound')
    groupNames = []

    for c in compounds:
        if c.attributes['kind'].nodeValue == 'group':
            group = get_text(c.getElementsByTagName('name')[0].childNodes)
            groupNames.append(group)

    return groupNames


def write_empty_spl_file(home_dir):
    """This one is tricky, if you don't know how Vim deals with its
    spelling dictionaries. For a proper explanation, refer to Vim
    documentation, and here it is sufficient to say, that I need a
    file 'fromtags.utf-8.spl', that is an empty dictionary. Vim will
    then not complain about being unable to find a dictionary. And all
    the real dictionary will be handled through another file,
    'fromtags.utf-8.add.spl', which is generated by this program.
    """

    empty_spl_file = 'VIMspell2\xff' + '\x00' * 13
    spl_filename = my_meta_spell_file + '.utf-8.spl'
    empty_spl_file_path = os.path.join(os.path.join(home_dir, '.vim/spell'),
                                       spl_filename)
    open(empty_spl_file_path, 'wb').write(empty_spl_file)


def read_things(home_dir):
    """Reads tags and XML files to gather all the information needed
    to put into our dictionary of identifiers.
    """

    words = []

    if my_tags_file:
        words.extend(get_word_list_from_tags(my_tags_file))
        print('tags read.')

    if my_index_xml:
        words.extend(parse_doxygen_index(my_index_xml))
        print('doxygen index read.')

    if len(words) == 0:
        print('Warning: there is no words to be added to dictionary...')
        print('Check if -t or -i options are specified.')

    return words


def write_things(home_dir, things):
    """Writes the plain text list of identifiers and then calls Vim
    to generate an actual dictionary for its use.
    """

    dictFile = home_dir + '/.vim/spell/' + my_meta_spell_file + '.utf-8.add'
    write_word_list(things, dictFile)
    print('word list written.')

    write_empty_spl_file(home_dir)

    # The following command line calls Vim to generate the binary
    # dictionary file it will actually be using, not the plain text
    # one we've just written with write_word_list.
    cmd = 'vim --cmd ":set encoding=utf-8" --cmd ":mkspell! %s" --cmd ":q"'
    os.system(cmd % (dictFile))
    print('spl generated.')


def clear_spell_files(home_dir):
    flist = [
        home_dir + '/.vim/spell/' + my_meta_spell_file + '.utf-8.spl',
        home_dir + '/.vim/spell/' + my_meta_spell_file + '.utf-8.add',
        home_dir + '/.vim/spell/' + my_meta_spell_file + '.utf-8.add.spl',
    ]

    # TODO: maybe we need to check if '.utf-8.spl' is empty spell file...
    # to prevent removing real spell files.

    for file in flist:
        if os.path.exists(file):
            print(" ...removing: %s" % (file))
            os.remove(file)


def usage():
    """Prints usage information.
    """

    print("""Usage: %(prog)s [-t <file>] [-i <file>] <metaspell>
       %(prog)s --clear <metaspell>

    -t <file>   tags file generated by Exuberant Ctags
    -i <file>   index xml file generated by Doxygen
    --clear     clear all generated spell files from your vim configuration
                directory
    -h, --help  this help

    <metaspell> name of vim spell file, that will be stored in your home
                directory:
                    ~/.vim/spell/<metaspell>.utf-8.spl
                    ~/.vim/spell/<metaspell>.utf-8.add
    """ % {'prog': sys.argv[0]})


def check_meta_spell_file_arg(args):
    global my_meta_spell_file

    if len(args) != 1:
        print("Metaspell file not specified. Nothing to do.\n")
        usage()
        sys.exit(2)
    else:
        my_meta_spell_file = args[0]


def main():
    global my_tags_file, my_index_xml

    home_dir = os.environ['HOME']

    try:
        opts, args = getopt.getopt(sys.argv[1:], 't::i::h', ['help', 'clear'])
    except getopt.GetoptError, err:
        print(str(err) + '\n')
        usage()
        sys.exit(2)

    my_tags_file = None
    my_index_xml = None

    for o, a in opts:
        if o == '-t':
            my_tags_file = a
        elif o == '-i':
            my_index_xml = a
        elif o == '--clear':
            check_meta_spell_file_arg(args)
            clear_spell_files(home_dir)
            sys.exit()
        elif o in ('-h', '--help'):
            usage()
            sys.exit()
        else:
            assert False, "unhandled option"

    check_meta_spell_file_arg(args)

    things = read_things(home_dir)
    write_things(home_dir, things)
    print('Done.')

if __name__ == '__main__':
    main()
